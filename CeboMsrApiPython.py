# CESYS Software License - Version 1.0 - January 1st, 2016
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The software must only be used to operate hardware manufactured by 
# CESYS GmbH, Herzogenaurach.
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# 
# Written by Thomas Hoppe <thomas.hoppe@cesys.com>, 2016

__author__  = "Thomas Hoppe"
__status__  = "production"
__version__ = "1.6"

import sys, platform
from ctypes import cdll, create_string_buffer, POINTER, byref
from ctypes import c_uint, c_int, c_char, c_char_p, c_float, c_longlong

def _getLibraryName():
    is64bit = sys.maxsize > 2**32
    baseName = "cebomsr-" + __version__
    if (platform.system() == "Windows"):
        return baseName + ("-x86_64.dll" if (is64bit) else "-x86.dll")
    if (platform.system() == "Linux"):
        return "lib" + baseName + ".so"
    if (platform.system() == "Darwin"):
        return "lib" + baseName + ".dylib"

def _buildFunction(call, args, result, errCheck = None):
    call.argtypes = args
    call.restype = result
    if (None != errCheck):
        call.errcheck = errCheck
    return call

def _isPython3():
    return sys.version_info[0] >= 3

def _createCharBuffer23(size):
    if (_isPython3()):
        return create_string_buffer(b'\000' * size)
    return create_string_buffer('\000' * size)

def _convertToString23(binaryString):
    if (_isPython3()):
        return binaryString.decode("utf-8")
    return binaryString

def _toString23(string):
    if (_isPython3()):
        return string.encode("utf-8")
    return string

def _getPeripheralName(handle, interfaceId):
    buf = _createCharBuffer23(_MaxIdentLength)
    _GetPeripheralName(handle, interfaceId, buf)
    return _convertToString23(buf.value)

def _checkError(result, func, args):
    if (result != 0):
        # This is an error, get size of buffer for error string.
        length = _GetErrorLength(result)

        # Retrieve error string.
        errb = _createCharBuffer23(length)
        _GetError(result, errb)
        error = _convertToString23(errb.value)

        # Raise exception depending on class.
        errorClass = result >> 24
        raise {
            0x80: AttributeError(error),
            0x40: IndexError(error),
            0x20: SystemError(error),
            0x10: IOError(error),
        }.get(errorClass, NotImplementedError("(internal) Unhandled error: " + error))

_CeboMsrTypeAll = 0xceb00000;
_CeboMsrTypeUsb = 0xceb00001;
_CeboMsrTypeCeboLC = 0xceb00010;
_CeboMsrTypeCeboStick = 0xceb00011;

_MaxIdentLength = 1024;

_CeboParameterSingleEndedCount = 0
_CeboParameterDifferentialCount = 1
_CeboParameterAnalogOutputCount = 2
_CeboParameterDigitalPortCount = 3
_CeboParameterCounterCount = 4
_CeboParameterTriggerCount = 5
_CeboParameterMaxInputFrames = 6
_CeboParameterCurrentSourceCount = 7
_CeboParameterLedCount = 8

_CeboMsrIoIdDigitalPort0 = 0xceb01000
_CeboMsrIoIdSingleEnded0 = 0xceb01100
_CeboMsrIoIdDifferential0 = 0xceb01200
_CeboMsrIoIdAnalogOutput0 = 0xceb01300
_CeboMsrRange0 = 0xceb01400
_CeboMsrRangeInvalid = 0xceb014ff
_CeboMsrIoIdCounter0 = 0xceb01500
_CeboMsrIoIdTrigger0 = 0xceb01600
_CeboMsrCurrentSource0 = 0xceb01700
_CeboMsrLedIndicator = 0xceb01800

_CeboMsrPeripheralResetMaskInputFifo = 0x00000001

_CeboMsrCounterConfigRisingEdge = 0xceb01a00
_CeboMsrCounterConfigFallingEdge = 0xceb01a01
_CeboMsrCounterConfigAlternating = 0xceb01a02

_CeboMsrTriggerOutputPulse = 0xceb01900
_CeboMsrTriggerOutputAlternating = 0xceb01901
_CeboMsrTriggerInputRisingEdge = 0xceb01902
_CeboMsrTriggerInputFallingEdge = 0xceb01903
_CeboMsrTriggerInputAlternating = 0xceb01904

_library = cdll.LoadLibrary(_getLibraryName())

# Error handling.
_GetErrorLength = _buildFunction(_library.CeboMsrGetErrorLength, [c_uint], c_int)
_GetError = _buildFunction(_library.CeboMsrGetError, [c_uint, POINTER(c_char) ], None)

# Host version information.
_GetApiVersion = _buildFunction(_library.CeboMsrGetApiVersion, [POINTER(c_char)], c_uint, _checkError)

# Enumeration.
_BeginEnumerate = _buildFunction(_library.CeboMsrBeginEnumerate, [POINTER(c_int), c_uint], c_uint, _checkError)
_BeginEnumerateNetwork = _buildFunction(_library.CeboMsrBeginEnumerateNetwork, [c_char_p, c_int, POINTER(c_int), c_uint], c_uint, _checkError)
_GetIdentifier = _buildFunction(_library.CeboMsrGetIdentifier, [c_int, POINTER(c_char), POINTER(c_uint), POINTER(c_char)], c_uint, _checkError)

# Access.
_Open = _buildFunction(_library.CeboMsrOpen, [c_char_p, POINTER(c_uint)], c_uint, _checkError)
_Close = _buildFunction(_library.CeboMsrClose, [c_uint], c_uint, _checkError)
_ResetDevice = _buildFunction(_library.CeboMsrResetDevice, [c_uint], c_uint, _checkError)
_ResetPeripherals = _buildFunction(_library.CeboMsrResetPeripherals, [c_uint, c_int ], c_uint, _checkError)

# Box specific.
_GetDeviceParameter = _buildFunction(_library.CeboMsrGetDeviceParameter, [c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_GetDigitalPortIoCount = _buildFunction(_library.CeboMsrGetDigitalPortIoCount, [c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_GetPeripheralName = _buildFunction(_library.CeboMsrGetPeripheralName, [c_uint, c_uint, POINTER(c_char)], c_uint, _checkError)
_GetDigitalPortIoName = _buildFunction(_library.CeboMsrGetDigitalPortIoName, [c_uint, c_uint, c_int, POINTER(c_char)], c_uint, _checkError)
_EnumerateRanges = _buildFunction(_library.CeboMsrEnumerateRanges, [c_uint, c_uint, c_int, POINTER(c_uint)], c_uint, _checkError)
_GetRangeMinMax = _buildFunction(_library.CeboMsrGetRangeMinMax, [c_uint, c_uint, c_uint, POINTER(c_float), POINTER(c_float)], c_uint, _checkError)
_GetDefaultAnalogInputInterChannelDelay = _buildFunction(_library.CeboMsrGetDefaultAnalogInputInterChannelDelay, [c_uint, c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_GetMinAnalogInputInterChannelDelay = _buildFunction(_library.CeboMsrGetMinAnalogInputInterChannelDelay, [c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_GetSerialNumber = _buildFunction(_library.CeboMsrGetSerialNumber, [c_uint, POINTER(c_char)], c_uint, _checkError)
_GetTemperature = _buildFunction(_library.CeboMsrGetTemperature, [c_uint, POINTER(c_float)], c_uint, _checkError)
_SetLed = _buildFunction(_library.CeboMsrSetLed, [c_uint, c_uint, c_int], c_uint, _checkError)
_GetReferenceCurrent = _buildFunction(_library.CeboMsrGetReferenceCurrent, [c_uint, c_uint, POINTER(c_float)], c_uint, _checkError)

# IO specific.
_SetDigitalPortOutputEnableMask = _buildFunction(_library.CeboMsrSetDigitalPortOutputEnableMask, [c_uint, c_uint, c_int], c_uint, _checkError)
_SetAnalogInputParameters = _buildFunction(_library.CeboMsrSetAnalogInputParameters, [c_uint, c_uint, c_uint, c_int, POINTER(c_int)], c_uint, _checkError)
_GetAnalogInputParameters = _buildFunction(_library.CeboMsrGetAnalogInputParameters, [c_uint, c_uint, POINTER(c_uint), POINTER(c_int)], c_uint, _checkError)
_SetTriggerEnable = _buildFunction(_library.CeboMsrSetTriggerEnable, [c_uint, c_uint, c_int], c_uint, _checkError)
_GetTriggerEnable = _buildFunction(_library.CeboMsrGetTriggerEnable, [c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_SetTriggerConfig = _buildFunction(_library.CeboMsrSetTriggerConfig, [c_uint, c_uint, c_uint], c_uint, _checkError)
_GetTriggerConfig = _buildFunction(_library.CeboMsrGetTriggerConfig, [c_uint, c_uint, POINTER(c_uint)], c_uint, _checkError)
_ResetCounter = _buildFunction(_library.CeboMsrResetCounter, [c_uint, c_uint], c_uint, _checkError)
_SetCounterEnable = _buildFunction(_library.CeboMsrSetCounterEnable, [c_uint, c_uint, c_int], c_uint, _checkError)
_GetCounterEnable = _buildFunction(_library.CeboMsrGetCounterEnable, [c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_SetCounterConfig = _buildFunction(_library.CeboMsrSetCounterConfig, [c_uint, c_uint, c_uint], c_uint, _checkError)
_GetCounterConfig = _buildFunction(_library.CeboMsrGetCounterConfig, [c_uint, c_uint, POINTER(c_uint)], c_uint, _checkError)

# Input specific.
_CalculateMaxBufferedInputFrames = _buildFunction(_library.CeboMsrCalculateMaxBufferedInputFrames, [c_uint, POINTER(c_int)], c_uint, _checkError)
_SetupInputFrame = _buildFunction(_library.CeboMsrSetupInputFrame, [c_uint, POINTER(c_uint), c_int], c_uint, _checkError)
_StartDataAcquisition = _buildFunction(_library.CeboMsrStartDataAcquisition, [c_uint, c_int, c_float, c_int, POINTER(c_float)], c_uint, _checkError)
_StopDataAcquisition = _buildFunction(_library.CeboMsrStopDataAcquisition, [c_uint], c_uint, _checkError)
_ReadBlocking = _buildFunction(_library.CeboMsrReadBlocking, [c_uint, POINTER(c_float), POINTER(c_int), c_int], c_uint, _checkError)
_ReadNonBlocking = _buildFunction(_library.CeboMsrReadNonBlocking, [c_uint, POINTER(c_float), POINTER(c_int), POINTER(c_int)], c_uint, _checkError)
_ReadDigitalPort = _buildFunction(_library.CeboMsrReadDigitalPort, [c_uint, c_uint, POINTER(c_int)], c_uint, _checkError)
_ReadAnalogInput = _buildFunction(_library.CeboMsrReadAnalogInput, [c_uint, c_uint, POINTER(c_float)], c_uint, _checkError)
_ReadFrame = _buildFunction(_library.CeboMsrReadFrame, [c_uint, POINTER(c_float), POINTER(c_int)], c_uint, _checkError)
_ReadCounter = _buildFunction(_library.CeboMsrReadCounter, [c_uint, c_uint, POINTER(c_longlong)], c_uint, _checkError)

# Output specific.
_SetupOutputFrame = _buildFunction(_library.CeboMsrSetupOutputFrame, [c_uint, POINTER(c_uint), c_int], c_uint, _checkError)
_WriteDigitalPort = _buildFunction(_library.CeboMsrWriteDigitalPort, [c_uint, c_uint, c_int], c_uint, _checkError)
_WriteAnalogOutput = _buildFunction(_library.CeboMsrWriteAnalogOutput, [c_uint, c_uint, c_float], c_uint, _checkError)
_WriteFrame = _buildFunction(_library.CeboMsrWriteFrame, [c_uint, POINTER(c_float), POINTER(c_int)], c_uint, _checkError)

class _DeviceType:
    """
    Values to be used in enumeration.
    """

    def __init__(self, interfaceId, name):
        self._interfaceId = interfaceId
        self.__name = name

    @staticmethod
    def _getDeviceTypeById(cid):
        return {
            _CeboMsrTypeAll: DeviceType.All,
            _CeboMsrTypeUsb: DeviceType.Usb,
            _CeboMsrTypeCeboLC: DeviceType.CeboLC,
            _CeboMsrTypeCeboStick: DeviceType.CeboStick,
        }[cid]

    def getName(self):
        """
        Return instance name as string, "Usb", "All", ...
        """
        return self.__name

# http://stackoverflow.com/questions/36932/whats-the-best-way-to-implement-an-enum-in-python
def _createDeviceTypeEnum(**enums):
    return type('_DeviceTypeEnum', (), enums)

DeviceType = _createDeviceTypeEnum(
    All = _DeviceType(_CeboMsrTypeAll, "All"),
    Usb = _DeviceType(_CeboMsrTypeUsb, "Usb"),
    CeboLC = _DeviceType(_CeboMsrTypeCeboLC, "CeboLC"),
    CeboStick = _DeviceType(_CeboMsrTypeCeboStick, "CeboStick")
)

class Range:
    """
    These objects are used to set the range of analog inputs and outputs.
    Direct construction is not possible, getSupportedRanges() of AnalogInput and
    AnalogOutput can be used to request the possible ranges of an input or output.
    """

    def __init__(self, interfaceId, minValue, maxValue, defaultInterChannelDelay):
        self._interfaceId = interfaceId
        self._minValue = minValue
        self._maxValue = maxValue
        self._defaultInterChannelDelay = defaultInterChannelDelay

    def getMinValue(self):
        """
        Return lower voltage as floating point value.
        """
        return self._minValue

    def getMaxValue(self):
        """
        Return upper voltage as floating point value.
        """
        return self._maxValue

class AnalogInput:
    """
    Offers functionality of the different kind of analog inputs.
    Direct construction is not possible, instances can be retrieved calling
    getSingleEndedInputs() or getDifferentialInputs() of the respective instance
    of class Device.
    """

    _StyleSingleEnded = 0
    _StyleDifferential = 1

    def __init__(self, device, interfaceId, style, styleIndex):
        self._device = device
        self._interfaceId = interfaceId
        self._style = style
        self._styleIndex = styleIndex
        self._name = _getPeripheralName(device._handle, interfaceId)
        self._supportedRanges = []

        i = 0
        while (True):
            rangeId = c_uint()
            _EnumerateRanges(device._handle, interfaceId, i, byref(rangeId))
            if (rangeId.value == _CeboMsrRangeInvalid):
                break

            minValue, maxValue = c_float(), c_float()
            _GetRangeMinMax(device._handle, interfaceId, rangeId, byref(minValue), byref(maxValue))

            icd = c_int()
            _GetDefaultAnalogInputInterChannelDelay(device._handle, interfaceId, rangeId, byref(icd))

            self._supportedRanges.append(Range(rangeId.value, minValue.value, maxValue.value, icd.value))

            i += 1

        micd = c_int()
        _GetMinAnalogInputInterChannelDelay(device._handle, interfaceId, byref(micd))
        self._minInterChannelDelay = micd.value

    def getSupportedRanges(self):
        """
        Return list of the supported ranges as tuple of class Range.
        """
        return tuple(self._supportedRanges)

    def getDefaultInterChannelDelay(self, inRange):
        """
        Request default interchannel delay at the given range setting as int.
        inRange: Object of type Range.
        """
        return inRange._defaultInterChannelDelay

    def getMinInterChannelDelay(self):
        """
        Returns minimum interchannel delay as int.
        """
        return self._minInterChannelDelay

    def setParameters(self, inRange, interChannelDelay=-1):
        """
        Set new range.
        inRange: Range level to set, type is class Range.
        interChannelDelay: Interchannel delay in microseconds, if -1, use default value for this range.
        return: Corrected interchannel delay in microseconds.
        """
        r = c_int()
        _SetAnalogInputParameters(self._device._handle, self._interfaceId, inRange._interfaceId, interChannelDelay, byref(r))

    def getRange(self):
        """
        Read active range level.
        return: The current range of type Range.
        """
        g, st = c_uint(), c_int()
        _GetAnalogInputParameters(self._device._handle, self._interfaceId, byref(g), byref(st))
        for r in self._supportedRanges:
            if (r._interfaceId == g.value):
                return r
        raise SystemError("Invalid range, internal error.")

    def getInterChannelDelay(self):
        """
        Read active interchannel delay.
        return: Interchannel delay as integer.
        """
        g, st = c_uint(), c_int()
        _GetAnalogInputParameters(self._device._handle, self._interfaceId, byref(g), byref(st))
        return st.value

    def read(self):
        """
        Read current voltage value as float.
        """
        r = c_float()
        _ReadAnalogInput(self._device._handle, self._interfaceId, byref(r))
        return r.value

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

class AnalogOutput:
    """
    Offers functionality for analog outputs. Direct construction
    is not possible. Instances can be retrieved calling getAnalogOutputs()
    of the respective Device class.
    """

    def __init__(self, device, interfaceId, index):
        self._device = device
        self._interfaceId = interfaceId
        self._index = index
        self._name = _getPeripheralName(device._handle, interfaceId)
        self._supportedRanges = []

        i = 0
        while (True):
            rangeId = c_uint()
            _EnumerateRanges(device._handle, interfaceId, i, byref(rangeId))
            if (rangeId.value == _CeboMsrRangeInvalid):
                break

            minValue, maxValue = c_float(), c_float()
            _GetRangeMinMax(device._handle, interfaceId, rangeId, byref(minValue), byref(maxValue))

            self._supportedRanges.append(Range(rangeId.value, minValue.value, maxValue.value, 0))

            i += 1

    def getSupportedRanges(self):
        """
        Return list of the supported ranges as tuple of class Range.
        """
        return tuple(self._supportedRanges)

    def setParameters(self, outRange):
        """
        Set new range.
        outRange: New range of type Range.
        """
        # No device currently supports this, included for future functionality.
        pass

    def getRange(self):
        """
        Read active range level.
        return: Current range of type Range.
        """
        # No device currently supports this, included for future functionality.
        return self._supportedRanges[0]

    def write(self, value):
        """
        Set voltage level directly.
        value: Value in volt to set as float.
        """
        _WriteAnalogOutput(self._device._handle, self._interfaceId, value)

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

class DigitalPort:
    """
    Offers functionality to work with digital ports. Direct construction
    is not possible. Instances can be retrieved calling getDigitalPorts() of
    the respective Device instance.
    """

    def __init__(self, device, interfaceId, index):
        self._device = device
        self._interfaceId = interfaceId
        self._index = index
        self._name = _getPeripheralName(device._handle, interfaceId)

        iob = c_int()
        _GetDigitalPortIoCount(device._handle, interfaceId, byref(iob))
        self._ioCount = iob.value

        self._ioNames = []
        for i in range(self._ioCount):
            buf = _createCharBuffer23(_MaxIdentLength)
            _GetDigitalPortIoName(device._handle, interfaceId, i, buf)
            self._ioNames.append(_convertToString23(buf.value))

    def setOutputEnableMask(self, mask):
        """
        Set output mask. The default mask is 0.
        mask: Mask to use, bits that have state '1' specify output direction.
        """
        _SetDigitalPortOutputEnableMask(self._device._handle, self._interfaceId, mask)

    def getIoCount(self):
        """
        Return count of I/O's for the specified port.
        """
        return self._ioCount

    def read(self):
        """
        Read value currently active on the port as integer.
        """
        r = c_int()
        _ReadDigitalPort(self._device._handle, self._interfaceId, byref(r))
        return r.value

    def write(self, value):
        """
        Set output I/O's. Only the bits that have been defined as output
        using setOutputEnableMask() are modified.
        value: Value to set on this port as integer.
        """
        _WriteDigitalPort(self._device._handle, self._interfaceId, value)

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

    def getIoName(self, io):
        """
        Return name of the I/O as specified by io.
        io: I/O index in range (0 <= io < getIoCount()).
        """
        return self._ioNames[io]

class Counter:
    """
    Offers functionality for counter periphery. Instances can be retrieved calling
    getCounters() of the respective Device instance.
    """
    class CounterConfig:
        """
        The possible counter configuration values.
        """
        RisingEdge = _CeboMsrCounterConfigRisingEdge
        FallingEdge = _CeboMsrCounterConfigFallingEdge
        Alternating = _CeboMsrCounterConfigAlternating

    def __init__(self, device, interfaceId, index):
        self._device = device
        self._interfaceId = interfaceId
        self._index = index
        self._name = _getPeripheralName(device._handle, interfaceId)

    def reset(self):
        """
        Reset counter to 0.
        """
        _ResetCounter(self._device._handle, self._interfaceId)

    def setEnabled(self, enabled):
        """
        Enable or disable counter.
        enabled: State to set as boolean.
        """
        _SetCounterEnable(self._device._handle, self._interfaceId, 1 if enabled else 0)

    def isEnabled(self):
        """
        Get current counter state as boolean.
        """
        r = c_int()
        _GetCounterEnable(self._device._handle, self._interfaceId, byref(r))
        return True if r != 0 else False

    def setConfig(self, counterConfig):
        """
        Define behavior of the counter.
        counterConfig Use one of the values from Counter::CounterConfig.
        """
        _SetCounterConfig(self._device._handle, self._interfaceId, counterConfig)

    def getConfig(self):
        """
        Request configuration of the counter.
        return: One of the values from Counter::CounterConfig.
        """
        r = c_uint()
        _GetCounterConfig(self._device._handle, self._interfaceId, byref(r))
        return r.value

    def read(self):
        """
        Read current counter value as long.
        """
        r = c_longlong()
        _ReadCounter(self._device._handle, self._interfaceId, byref(r))
        return r.value

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

class Trigger:
    """
    Offers functionality for triggers. Instances can be retrieved calling getTriggers()
    of the respective Device instance.
    """

    class TriggerConfig:
        """
        The possible trigger configuration values.
        """
        OutputPulse = _CeboMsrTriggerOutputPulse
        OutputAlternating = _CeboMsrTriggerOutputAlternating
        InputRisingEdge  = _CeboMsrTriggerInputRisingEdge
        InputFallingEdge = _CeboMsrTriggerInputFallingEdge
        InputAlternating = _CeboMsrTriggerInputAlternating

    def __init__(self, device, interfaceId, index):
        self._device = device
        self._interfaceId = interfaceId
        self._index = index
        self._name = _getPeripheralName(device._handle, interfaceId)

    def setEnabled(self, enabled):
        """
        Enable or disable trigger.
        enabled: State to set as boolean.
        """
        _SetTriggerEnable(self._device._handle, self._interfaceId, 1 if enabled else 0)

    def isEnabled(self):
        """
        Get current counter state as boolean.
        """
        r = c_int()
        _GetTriggerEnable(self._device._handle, self._interfaceId, byref(r))
        return True if r != 0 else False

    def setConfig(self, triggerConfig):
        """
        Define behavior of the trigger.
        triggerConfig: Use one of the values from Trigger.TriggerConfig.
        """
        _SetTriggerConfig(self._device._handle, self._interfaceId, triggerConfig)

    def getConfig(self):
        """
        Request configuration of the trigger.
        return: One of the values from Trigger.TriggerConfig.
        """
        r = c_uint()
        _GetTriggerConfig(self._device._handle, self._interfaceId, byref(r))
        return r.value

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

class Led:
    """
    Offers functionality for LED's. Instances can be retrieved using getLeds()
    of the respective Device instance.
    """

    def __init__(self, device, interfaceId, index):
        self._device = device
        self._interfaceId = interfaceId
        self._index = index
        self._name = _getPeripheralName(device._handle, interfaceId)

    def setEnabled(self, state):
        """
        Set state of the on-board led.
        state: Boolean expression for LED state.
        """
        _SetLed(self._device._handle, self._interfaceId, 1 if state else 0)

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

class CurrentSource:
    """
    Offers functionality for current sources. Instances can be retrieved using
    getCurrentSources() of the respective Device instance.
    """

    def __init__(self, device, interfaceId, index):
        self._device = device
        self._interfaceId = interfaceId
        self._index = index
        self._name = _getPeripheralName(device._handle, interfaceId)

    def getReferenceCurrent(self):
        """
        Returns the real current of the constant current source in micro ampere.
        """
        r = c_float()
        _GetReferenceCurrent(self._device._handle, self._interfaceId, byref(r))
        return r.value

    def getName(self):
        """
        Return name of the component.
        """
        return self._name

class InputFrame:
    """
    One or more instances of this interface are returned when reading one or multiple
    frames previously setup using Device.setupInputFrame(). It allows
    simple access to all captured data.
    """

    def __init__(self,
            vvalues, values,
            singleEndedOffset, singleEndedCount,
            differentialOffset, differentialCount,
            digitalPortOffset, digitalPortCount,
            counterOffset, counterCount,
            triggerOffset, triggerCount):
        self._vvalues = vvalues
        self._values = values
        self._singleEndedOffset = singleEndedOffset
        self._singleEndedCount = singleEndedCount
        self._differentialOffset = differentialOffset
        self._differentialCount = differentialCount
        self._digitalPortOffset = digitalPortOffset
        self._digitalPortCount = digitalPortCount
        self._counterOffset = counterOffset
        self._counterCount = counterCount
        self._triggerOffset = triggerOffset
        self._triggerCount = triggerCount

    def getSingleEnded(self, index):
        """
        Read value from single ended input with given index.
        index: Zero based index of single ended input in question.
        return: Value of this input in voltage.
        """
        if (index < 0 or index >= self._singleEndedCount):
            raise IndexError()
        return self._vvalues[self._singleEndedOffset + index]

    def getDifferential(self, index):
        """
        Read value from differential input with given index.
        index: Zero based index of differential input in question.
        return: Value of this input in voltage.
        """
        if (index < 0 or index >= self._differentialCount):
            raise IndexError()
        return self._vvalues[self._differentialOffset + index]

    def getDigitalPort(self, index):
        """
        Read value from digital port with given index.
        index: Zero based index of digital port in question.
        return: Active mask of digital port.
        """
        if (index < 0 or index >= self._digitalPortCount):
            raise IndexError()
        return self._values[self._digitalPortOffset + index]

    def getTrigger(self, index):
        """
        Read level from trigger with given index.
        index: Zero based index of trigger in question.
        return: Current level of trigger, True equals a high level.
        """
        if (index < 0 or index >= self._triggerCount):
            raise IndexError()
        return 0 != self._values[self._triggerOffset + index]

    def getCounter(self, index):
        """
        Read value of specified counter.
        index: Zero based index of counter in question.
        return: Current counter value.
        """
        if (index < 0 or index >= self._counterCount):
            raise IndexError()
        return self._values[self._counterOffset + index] & 0xffffffff

class OutputFrame:
    """
    Class to use when setting multiple outputs simultaneous. Do not construct directly,
    as the count of the the various elements varies from device type to device type. Instances
    must be generated calling Device.createOutputFrame().
    """

    def __init__(self, vcount, count):
        self._vvalues = vcount * [0.0]
        self._values = count * [0]

    def setDigitalPort(self, index, value):
        """
        Define value that should be set on the specified digital port.
        index: Zero based index of port to specify.
        value: Value to set at this port.
        """
        if (index < 0 or index > len(self._values)):
            raise IndexError()
        self._values[index] = value

    def setAnalogOutput(self, index, value):
        """
        Define value that should be set on the specified analog output.
        index: Zero based index of output to specify.
        value: Value to set at this output.
        """
        if (index < 0 or index > len(self._vvalues)):
            raise IndexError()
        self._vvalues[index] = value

class Device:
    """
    The primary object to communicate with a CeboMsr-compatible device. Every instance holds a single
    connection to a device. Instances are created during enumeration in LibraryInterface.enumerate().
    """

    # Valid flags to use with Device.resetPeripherals().
    FlagResetInputFifo = _CeboMsrPeripheralResetMaskInputFifo

    def __getOutputFrameFloatCount(self):
        return len(self._analogOuputs)

    def __getOutputFrameIntCount(self):
        return len(self._digitalPorts)

    def __getInputFrameFloatCount(self):
        return len(self._singleEnded) + len(self._differential)

    def __getInputFrameIntCount(self):
        return len(self._digitalPorts) + len(self._counters) + len(self._triggers)

    def __getDeviceParameter(self, param):
        r = c_int()
        _GetDeviceParameter(self._handle, param, byref(r))
        return r.value

    def __buildInputFrame(self, vvalues, values, frameNum):
        voffset = frameNum * self.__getInputFrameFloatCount()
        offset = frameNum * self.__getInputFrameIntCount()
        return InputFrame(
            vvalues, values,
            voffset, len(self._singleEnded),
            voffset + len(self._singleEnded), len(self._differential),
            offset, len(self._digitalPorts),
            offset + len(self._digitalPorts), len(self._counters),
            offset + len(self._digitalPorts) + len(self._counters), len(self._triggers)
        )

    def __init__(self, ident, msrType, version):
        self._ident = ident
        self._msrType = msrType
        self._version = version
        self._handle = -1

    def open(self):
        """
        Open device.
        """
        handleb = c_uint()
        _Open(_toString23(self._ident), byref(handleb))
        self._handle = handleb.value

        self._singleEnded = []
        for i in range(self.__getDeviceParameter(_CeboParameterSingleEndedCount)):
            self._singleEnded.append(AnalogInput(self, _CeboMsrIoIdSingleEnded0 + i, AnalogInput._StyleSingleEnded, i))

        self._differential = []
        for i in range(self.__getDeviceParameter(_CeboParameterDifferentialCount)):
            self._differential.append(AnalogInput(self, _CeboMsrIoIdDifferential0 + i, AnalogInput._StyleDifferential, i))

        self._analogOuputs = []
        for i in range(self.__getDeviceParameter(_CeboParameterAnalogOutputCount)):
            self._analogOuputs.append(AnalogOutput(self, _CeboMsrIoIdAnalogOutput0 + i, i))

        self._digitalPorts = []
        for i in range(self.__getDeviceParameter(_CeboParameterDigitalPortCount)):
            self._digitalPorts.append(DigitalPort(self, _CeboMsrIoIdDigitalPort0 + i, i))

        self._counters = []
        for i in range(self.__getDeviceParameter(_CeboParameterCounterCount)):
            self._counters.append(Counter(self, _CeboMsrIoIdCounter0 + i, i))

        self._triggers = []
        for i in range(self.__getDeviceParameter(_CeboParameterTriggerCount)):
            self._triggers.append(Trigger(self, _CeboMsrIoIdTrigger0 + i, i))

        self._currentSources = []
        for i in range(self.__getDeviceParameter(_CeboParameterCurrentSourceCount)):
            self._currentSources.append(CurrentSource(self, _CeboMsrCurrentSource0 + i, i))

        self._leds = []
        for i in range(self.__getDeviceParameter(_CeboParameterLedCount)):
            self._leds.append(Led(self, _CeboMsrLedIndicator + i, 0))

        self._maxInputFrames = self.__getDeviceParameter(_CeboParameterMaxInputFrames)

    def close(self):
        """
        Close device.
        """
        _Close(self._handle)

    def resetDevice(self):
        """
        Restore startup defaults in device.
        """
        _ResetDevice(self._handle)

    def resetPeripherals(self, mask):
        """
        Reset specified elements in device.
        mask: Bit vector constructed of Device.FlagReset*
        """
        _ResetPeripherals(self._handle, mask)

    def getIdentifier(self):
        """
        Return unique id of device.
        """
        return self._ident

    def getDeviceType(self):
        """
        Get actual type of device.
        """
        return self._msrType

    def getFirmwareVersion(self):
        """
        Read string which contains the firmware version.
        """
        return self._version

    def getSerialNumber(self):
        """
        Return serial number of device.
        """
        r = _createCharBuffer23(_MaxIdentLength)
        _GetSerialNumber(self._handle, r)
        return _convertToString23(r.value)

    def getTemperature(self):
        """
        Read device temperature in degree celsius.
        """
        r = c_float()
        _GetTemperature(self._handle, byref(r))
        return r.value

    def calculateMaxBufferedInputFrames(self):
        """
        Calculate maximum count of frames that can be buffered on the device when using
        multiple frame mode. Depends on the actively selected inputs.
        return: Frame count as integer.
        """
        r = c_int()
        _CalculateMaxBufferedInputFrames(self._handle, byref(r))
        return r.value

    def setupInputFrame(self, inputs):
        """
        Define the inputs that were included in the next frame request
        (readFrame(), readBlocking() and readNonBlocking()).
        inputs: Collection of inputs.
        """
        v = []
        for i in range(len(inputs)):
            if (isinstance(inputs[i], (AnalogInput, DigitalPort, Counter, Trigger))):
                v.append(inputs[i]._interfaceId)
            else:
                raise AttributeError("Unknown input.")
        vt = (len(inputs) * c_uint)(*v)
        _SetupInputFrame(self._handle, vt, len(inputs))

    def startBufferedDataAcquisition(self, frameRate, frameCount, externalStarted):
        """
        Initialize a buffered data acquisition. Frames are buffered in the device memory,
        so frame loss is not possible.
        frameRate: Frequency in Hz to capture frame as float.
        frameCount: Maximum count of frames to capture as int. Maximum possible frames can
                         calculated using calculateMaxBufferedInputFrames().
        externalStarted: If True, sampling starts if an external trigger is detected,
                        immediately otherwise.
        return: Corrected frame rate as float.
        """
        if (frameRate <= 0):
            raise AttributeError("frameRate must be > 0")
        if (frameCount <= 0):
            raise AttributeError("frameCount must be > 0")
        r = c_float()
        _StartDataAcquisition(self._handle, 1 if externalStarted else 0, frameRate, frameCount, byref(r))
        return r.value

    def startBufferedExternalTimedDataAcquisition(self, frameCount):
        """
        Initialize a buffered data acquisition. Frames are buffered in the device memory,
        so frame loss is not possible.
        Too high frequency on the external trigger will create frame loss.
        frameCount: Maximum count of frames to capture as int. Maximum possible frames can
                         calculated using calculateMaxBufferedInputFrames().
        """
        if (frameCount <= 0):
            raise AttributeError("frameCount must be > 0")
        r = c_float()
        _StartDataAcquisition(self._handle, 1, -1, frameCount, byref(r))

    def startContinuousDataAcquisition(self, frameRate, externalStarted):
        """
        Initialize a continuous data acquisition. Data must be read as fast as possible using
        readBlocking()/readNonBlocking(), otherwise  an device buffer overflow may occur.
        frameRate: Frequency in Hz to capture frame as float.
        externalStarted: If True, sampling starts if an external trigger is detected,
                        immediately otherwise.
        return: Corrected frame rate as float.
        """
        if (frameRate <= 0):
            raise AttributeError("frameRate must be > 0")
        r = c_float()
        _StartDataAcquisition(self._handle, 1 if externalStarted else 0, frameRate, -1, byref(r))
        return r.value

    def startContinuousExternalTimedDataAcquisition(self):
        """
        Initialize a continuous data acquisition. Data must be read as fast as possible
        using readBlocking()/readNonBlocking(), otherwise an device buffer overflow may occur.
        For every detected trigger, one frame is captured. Too high frequency on the external
        trigger will create frame loss.
        """
        r = c_float()
        _StartDataAcquisition(self._handle, 1, -1, -1, byref(r))

    def stopDataAcquisition(self):
        """
        Stop any form of hardware managed data acquisition.
        """
        _StopDataAcquisition(self._handle)

    def readBlocking(self, frameCount):
        """
        Read exact frameCount frames, return after completion, blocks until all data is available.
        frameCount: Count of frames to read.
        return: Tuple of read frames.
        """
        vvalues = ((frameCount * self.__getInputFrameFloatCount()) * c_float)()
        values = ((frameCount * self.__getInputFrameIntCount()) * c_int)()
        _ReadBlocking(self._handle, vvalues, values, frameCount)
        r = []
        for i in range(frameCount):
            r.append(self.__buildInputFrame(vvalues, values, i))
        return tuple(r)

    def readNonBlocking(self):
        """
        Read at much possible available frames, return immediately.
        return: Tuple of frames available at the moment of reading, 0 <= count <= max possible.
        """
        vvalues = ((self._maxInputFrames * self.__getInputFrameFloatCount()) * c_float)()
        values = ((self._maxInputFrames * self.__getInputFrameIntCount()) * c_int)()
        frameCount = c_int()
        _ReadNonBlocking(self._handle, vvalues, values, frameCount)
        r = []
        for i in range(frameCount.value):
            r.append(self.__buildInputFrame(vvalues, values, i))
        return tuple(r)

    def readFrame(self):
        """
        Read multiple inputs using the previously defined list (setupInputFrame()).
        return: InputFrame that contains the values of all specified inputs.
        """
        vvalues = (self.__getInputFrameFloatCount() * c_float)()
        values = (self.__getInputFrameIntCount() * c_int)()
        _ReadFrame(self._handle, vvalues, values)
        return self.__buildInputFrame(vvalues, values, 0)

    def setupOutputFrame(self, outputs):
        """
        Define the outputs that should be set using the next frame based out transfer.
        inputs: Collection of outputs.
        """
        v = []
        for i in range(len(outputs)):
            if (isinstance(outputs[i], (AnalogOutput, DigitalPort))):
                v.append(outputs[i]._interfaceId)
            else:
                raise AttributeError("Unknown output.")
        vt = (len(outputs) * c_uint)(*v)
        _SetupOutputFrame(self._handle, vt, len(outputs))

    def writeFrame(self, frame):
        """
        Write multiple outputs at once. All outputs specified using setupOutputFrame() are modified using
        the values in the frame.
        frame: Instance that holds all values to set.
        """
        vvalues = (len(frame._vvalues) * c_float)(*frame._vvalues)
        values = (len(frame._values) * c_int)(*frame._values)
        _WriteFrame(self._handle, vvalues, values)

    def createOutputFrame(self):
        """
        Create OutputFrame instance specific to this device.
        return: New instance of OutputFrame.
        """
        return OutputFrame(self.__getOutputFrameFloatCount(), self.__getOutputFrameIntCount())

    def getSingleEndedInputs(self):
        """
        Return list of single ended analog inputs.
        """
        return tuple(self._singleEnded)

    def getDifferentialInputs(self):
        """
        Return list of differential analog inputs.
        """
        return tuple(self._differential)

    def getAnalogOutputs(self):
        """
        Return list of analog outputs.
        """
        return tuple(self._analogOuputs)

    def getDigitalPorts(self):
        """
        Return list of digital ports.
        """
        return tuple(self._digitalPorts)

    def getCounters(self):
        """
        Return list of counters.
        """
        return tuple(self._counters)

    def getTriggers(self):
        """
        Return list of triggers.
        """
        return tuple(self._triggers)

    def getCurrentSources(self):
        """
        Return list of current sources.
        """
        return tuple(self._currentSources)

    def getLeds(self):
        """
        Return list of LED's.
        """
        return tuple(self._leds)

class LibraryInterface:
    """
    Class that is responsible for all device independent functionality.
    """

    @staticmethod
    def getApiVersion():
        """
        Version of the CeboMsr-Base-API.
        return: Version string.
        """
        r = _createCharBuffer23(_MaxIdentLength)
        _GetApiVersion(r)
        return _convertToString23(r.value)

    @staticmethod
    def enumerate(deviceType):
        """
        Enumerate devices on this system. Already opened devices are not included.
        deviceType: Type of devices to enumerate.
        return: Tuple containing devices as types of class Device.
        """
        countb = c_int()
        _BeginEnumerate(byref(countb), deviceType._interfaceId)
        r = []
        for i in range(countb.value):
            ident = _createCharBuffer23(_MaxIdentLength)
            msrType = c_uint()
            version = _createCharBuffer23(_MaxIdentLength)
            _GetIdentifier(i, ident, byref(msrType), version)
            r.append(Device(_convertToString23(ident.value), _DeviceType._getDeviceTypeById(msrType.value), _convertToString23(version.value)))
        return tuple(r)

    @staticmethod
    def enumerateNetwork(hostname, port, deviceType):
        """
        *** unofficial experimental feature, don't use ***
        """
        countb = c_int()
        _BeginEnumerateNetwork(_toString23(hostname), port, byref(countb), deviceType._interfaceId)
        r = []
        for i in range(countb.value):
            ident = _createCharBuffer23(_MaxIdentLength)
            msrType = c_uint()
            version = _createCharBuffer23(_MaxIdentLength)
            _GetIdentifier(i, ident, byref(msrType), version)
            r.append(Device(_convertToString23(ident.value), _DeviceType._getDeviceTypeById(msrType.value), _convertToString23(version.value)))
        return tuple(r)
